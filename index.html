<html>
  <head>
    <style>
      body {
        background: #f2c335;
        display: flex;
        color: white;
        height: 100%;
        width: 100%;
        margin: 0;
      }

      .main {
        height: 10rem;
        margin: auto;
        display: flex;
        flex-direction: column;
      }

      svg {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        fill: none;
        stroke: #fff;
        stroke-width: 2;
        stroke-linecap: round;
      }

      svg path {
        transition: all 0.4s ease;
        /* stroke-dashoffset: 0; */
        /* animation: pass-by 3000ms cubic-bezier(0.785, 0.135, 0.15, 0.86)
          infinite both;
        stroke-dasharray: 7090;
        --stroke-dashoffset: 7090;
        --stroke-dashoffset-negative: -7090; */
      }
    </style>
    <script src="https://mdn.github.io/webgl-examples/tutorial/gl-matrix.js"></script>
  </head>
  <body>
    <script>
      var cubeRotation = 0.0;

      function main() {
        const canvas = document.createElement("canvas");
        const { width, height } = document.body.getBoundingClientRect();
        canvas.setAttribute("width", width);
        canvas.setAttribute("height", height);
        document.body.appendChild(canvas);

        const gl = canvas.getContext("webgl");

        if (gl === null) {
          return;
        }

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        const vsSource = `
          attribute vec4 aVertexPosition;
          attribute vec4 aVertexColor;

          uniform mat4 uModelViewMatrix;
          uniform mat4 uProjectionMatrix;

          varying lowp vec4 vColor;

          void main() {
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
            vColor = aVertexColor;
          }
        `;

        const fsSource = `
          varying lowp vec4 vColor;

          void main() {
            gl_FragColor = vColor;
          }
        `;

        function initShaderProgram(gl, vsSource, fsSource) {
          const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
          const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

          const shaderProgram = gl.createProgram();
          gl.attachShader(shaderProgram, vertexShader);
          gl.attachShader(shaderProgram, fragmentShader);
          gl.linkProgram(shaderProgram);

          if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.log("failed to initialize shader program");
            return null;
          }

          return shaderProgram;
        }

        function loadShader(gl, type, source) {
          const shader = gl.createShader(type);

          gl.shaderSource(shader, source);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.log("failed to compile shader");
            gl.deleteShader(shader);
            return null;
          }

          return shader;
        }

        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

        const programInfo = {
          program: shaderProgram,
          attribLocations: {
            vertexPosition: gl.getAttribLocation(
              shaderProgram,
              "aVertexPosition"
            ),
            vertexColor: gl.getAttribLocation(shaderProgram, "aVertexColor")
          },
          uniformLocations: {
            projectionMatrix: gl.getUniformLocation(
              shaderProgram,
              "uProjectionMatrix"
            ),
            modelViewMatrix: gl.getUniformLocation(
              shaderProgram,
              "uModelViewMatrix"
            )
          }
        };

        const buffers = initBuffers(gl);

        var then = 0;

        // Draw the scene repeatedly
        function render(now) {
          now *= 0.001; // convert to seconds
          const deltaTime = now - then;
          then = now;

          drawScene(gl, programInfo, buffers, deltaTime);

          requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        console.log("hej");
      }

      function initBuffers(gl) {
        const positionBuffer = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        const positions = [
          // Front face
          -1.0,
          -1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          1.0,

          // Back face
          -1.0,
          -1.0,
          -1.0,
          -1.0,
          1.0,
          -1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          -1.0,
          -1.0,

          // Top face
          -1.0,
          1.0,
          -1.0,
          -1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          -1.0,

          // Bottom face
          -1.0,
          -1.0,
          -1.0,
          1.0,
          -1.0,
          -1.0,
          1.0,
          -1.0,
          1.0,
          -1.0,
          -1.0,
          1.0,

          // Right face
          1.0,
          -1.0,
          -1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          -1.0,
          1.0,

          // Left face
          -1.0,
          -1.0,
          -1.0,
          -1.0,
          -1.0,
          1.0,
          -1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          -1.0
        ];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(positions),
          gl.STATIC_DRAW
        );

        const faceColors = [
          [1.0, 1.0, 1.0, 1.0], // Front face: white
          [1.0, 0.0, 0.0, 1.0], // Back face: red
          [0.0, 1.0, 0.0, 1.0], // Top face: green
          [0.0, 0.0, 1.0, 1.0], // Bottom face: blue
          [1.0, 1.0, 0.0, 1.0], // Right face: yellow
          [1.0, 0.0, 1.0, 1.0] // Left face: purple
        ];

        var colors = [];

        for (var j = 0; j < faceColors.length; ++j) {
          const c = faceColors[j];

          // Repeat each color four times for the four vertices of the face
          colors = colors.concat(c, c, c, c);
        }

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(colors),
          gl.STATIC_DRAW
        );

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        const indices = [
          0,
          1,
          2,
          0,
          2,
          3, // front
          4,
          5,
          6,
          4,
          6,
          7, // back
          8,
          9,
          10,
          8,
          10,
          11, // top
          12,
          13,
          14,
          12,
          14,
          15, // bottom
          16,
          17,
          18,
          16,
          18,
          19, // right
          20,
          21,
          22,
          20,
          22,
          23 // left
        ];

        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indices),
          gl.STATIC_DRAW
        );

        return {
          position: positionBuffer,
          color: colorBuffer,
          indices: indexBuffer
        };
      }

      function drawScene(gl, programInfo, buffers, deltaTime) {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clearDepth(1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const fieldOfView = (45 * Math.PI) / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();

        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        const modelViewMatrix = mat4.create();

        mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);
        mat4.rotate(
          modelViewMatrix, // destination matrix
          modelViewMatrix, // matrix to rotate
          cubeRotation, // amount to rotate in radians
          [0, 0, 1]
        );
        mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation * 0.7, [
          0,
          1,
          0
        ]);

        {
          const numComponents = 3;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;

          const offset = 0;
          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
          gl.vertexAttribPointer(
            programInfo.attribLocations.vertexPosition,
            numComponents,
            type,
            normalize,
            stride,
            offset
          );
          gl.enableVertexAttribArray(
            programInfo.attribLocations.vertexPosition
          );
        }

        {
          const numComponents = 4;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;
          const offset = 0;

          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
          gl.vertexAttribPointer(
            programInfo.attribLocations.vertexColor,
            numComponents,
            type,
            normalize,
            stride,
            offset
          );
          gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);
        }

        gl.useProgram(programInfo.program);

        gl.uniformMatrix4fv(
          programInfo.uniformLocations.projectionMatrix,
          false,
          projectionMatrix
        );
        gl.uniformMatrix4fv(
          programInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix
        );

        {
          const offset = 0;
          const vertexCount = 4;
          gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
        }

        {
          const vertexCount = 36;
          const type = gl.UNSIGNED_SHORT;
          const offset = 0;
          gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
        }

        cubeRotation += deltaTime;
      }

      window.onload = main;
    </script>
  </body>
</html>
