<html>
  <head>
    <style>
      body {
        background: #f2c335;
        display: flex;
        color: white;
        height: 100%;
        width: 100%;
        margin: 0;
      }

      .main {
        height: 10rem;
        margin: auto;
        display: flex;
        flex-direction: column;
      }

      svg {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        fill: none;
        stroke: #fff;
        stroke-width: 2;
        stroke-linecap: round;
      }

      svg path {
        transition: all 0.4s ease;
        /* stroke-dashoffset: 0; */
        /* animation: pass-by 3000ms cubic-bezier(0.785, 0.135, 0.15, 0.86)
          infinite both;
        stroke-dasharray: 7090;
        --stroke-dashoffset: 7090;
        --stroke-dashoffset-negative: -7090; */
      }
    </style>
    <script src="https://mdn.github.io/webgl-examples/tutorial/gl-matrix.js"></script>
  </head>
  <body>
    <script>
      function main() {
        const canvas = document.createElement("canvas");
        const { width, height } = document.body.getBoundingClientRect();
        canvas.setAttribute("width", width);
        canvas.setAttribute("height", height);
        document.body.appendChild(canvas);

        const gl = canvas.getContext("webgl");

        if (gl === null) {
          return;
        }

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        const vsSource = `
          attribute vec4 aVertexPosition;

          uniform mat4 uModelViewMatrix;
          uniform mat4 uProjectionMatrix;

          void main() {
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
          }
        `;

        const fsSource = `
          void main() {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
          }
        `;

        function initShaderProgram(gl, vsSource, fsSource) {
          const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
          const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

          const shaderProgram = gl.createProgram();
          gl.attachShader(shaderProgram, vertexShader);
          gl.attachShader(shaderProgram, fragmentShader);
          gl.linkProgram(shaderProgram);

          if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.log("failed to initialize shader program");
            return null;
          }

          return shaderProgram;
        }

        function loadShader(gl, type, source) {
          const shader = gl.createShader(type);

          gl.shaderSource(shader, source);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.log("failed to compile shader");
            gl.deleteShader(shader);
            return null;
          }

          return shader;
        }

        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

        const programInfo = {
          program: shaderProgram,
          attribLocations: {
            vertexPosition: gl.getAttribLocation(
              shaderProgram,
              "aVertexPosition"
            )
          },
          uniformLocations: {
            projectionMatrix: gl.getUniformLocation(
              shaderProgram,
              "uProjectionMatrix"
            ),
            modelViewMatrix: gl.getUniformLocation(
              shaderProgram,
              "uModelViewMatrix"
            )
          }
        };

        const buffers = initBuffers(gl);

        drawScene(gl, programInfo, buffers);
        console.log("hej");
      }

      function initBuffers(gl) {
        const positionBuffer = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(positions),
          gl.STATIC_DRAW
        );

        return {
          position: positionBuffer
        };
      }

      function drawScene(gl, programInfo, buffers) {
        console.log(programInfo);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clearDepth(1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const fieldOfView = (45 * Math.PI) / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();

        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        const modelViewMatrix = mat4.create();

        mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0]);

        {
          const numComponents = 2;
          const type = gl.FLOAT;
          const normalize = false;
          const stride = 0;

          const offset = 0;
          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
          gl.vertexAttribPointer(
            programInfo.attribLocations.vertexPosition,
            numComponents,
            type,
            normalize,
            stride,
            offset
          );
          gl.enableVertexAttribArray(
            programInfo.attribLocations.vertexPosition
          );
        }

        gl.useProgram(programInfo.program);

        gl.uniformMatrix4fv(
          programInfo.uniformLocations.projectionMatrix,
          false,
          projectionMatrix
        );
        gl.uniformMatrix4fv(
          programInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix
        );

        {
          const offset = 0;
          const vertexCount = 4;
          gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
        }
      }

      window.onload = main;
    </script>
  </body>
</html>
